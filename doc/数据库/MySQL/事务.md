## 事务

### 1. 事务基础

#### 1.1 事务

事务是逻辑上的一组操作，这组操作要么全部成功，要么全部失败。本质是并发问题。客户端与MySQL建立连接后，一个连接开启一次会话Session，每个会话可以多次开启和提交事务。

MySQL中只有InnoDB支持事务。

#### 1.2 四大特性

- 原子性（Atomicity）：指事务不可分割，操作要么都发生，要么都不发生。
- 一致性（Consistency）：事务前后数据的完整性必须保持一致。
- 隔离性（Isolation）：多个用户并发访问数据库，一个用户的事务不能被其他用户的事务干扰。
- 持久性（Durability）：一个事务一旦被提交，对数据库的改变是永久性的，即使数据库发生故障也不会有影响。

#### 1.3 并发问题

- 脏读：一个事务读到了另一个事务未提交的数据。
- 不可重复读：一个事务读到了另一个事务已经修改（update）的数据，引发事务中的多次查询结果不一致。
- 幻读：一个事务读到了另一个事务已经新增（Insert）的数据，引发事务中的多次查询结果不一致。

#### 1.4 隔离级别

- 读未提交RU：Read Uncommitted，一个事务读到另一个事务没有提交的数据

  出现问题：脏读，不可重复读、幻读

- 读已提交RC：Read Committed，一个事务读到另一个事务已经提交的数据

  **Oracle默认隔离级别**

  出现问题：不可重复读、幻读

- 可重复读RR：Repeatable Read，一个事务中读到的数据始终保持一致，无论另一个事务是否提交

  **MySQL默认隔离级别**

  出现问题：幻读

- 串行化读：Serializable，同时只能执行一个事务，相当于单线程。

性能：串行化读 < 可重复读RR < 读已提交RC < 读未提交RU

安全性：串行化读 > 可重复读RR > 读已提交RC > 读未提交RU

### 2. 事务原理

#### 2.1 丢失更新问题

两个事务针对同一数据进行修改操作时会丢失更新。

#### 2.2 解决丢失更新方案

##### 2.2.1 基于锁的LBCC

一个事务去读取一条数据，加锁，不允许其他事务操作。确保当前事务，其他事务不会对当前数据产生影响。当前事务读取到的数据只能是最新的。

基于锁会大大降低数据库的性能。

##### 2.2.2 基于版本的MVCC

事务读取数据，不会读取事务修改后的数据，而是读取本事务开始时的副本数据（快照数据）。

MVCC使得读不加锁，读写不冲突，显著提高了数据库的并发处理能力。

### 3. MVCC

#### 3.1 MVCC

MVCC（Multiversion concurrency control）多版本并发控制。是关系型数据库常用的一种并发控制方法，用来对数据库数据进行并发访问，实现事务。核心思想：读不加锁，读写不冲突。

MVCC实现原理关键在于数据快照，不同的事务访问不同版本的数据快照，从而实现事务对数据的隔离级别。

实现依赖于`Undo Log`与`Read View`。

InnoDB的表有默认字段和可见字段，默认字段是实现MVCC的关键，默认字段是隐藏的列。默认字段最关键的两个列，一个保存了行的事务ID，一个保存了行的回滚指针。每开始新事务，都会字段递增产生一个新事务ID，事务开始后，生成当前事务影响行的ReadView，当查询时，需要用当前查询的事务Id与ReadView确定要查询的数据版本。

#### 3.2 Undo Log

 对数据修改时，InnoDB会产生一定量的Undo日志，如果事务执行失败Rollback了，则利用Undo日志回滚到历史版本。

Undo日志可以解决丢失更新问题。

存储位置：系统表空间的回滚段中。

对于更新和删除操作，InnoDB并不是真正的删除原来的记录，而是设置记录的delete mark为1。为了解决数据Page和Undo日志膨胀问题，需要回收机制进行清理Undo日志。

Undo日志分为两种：`Insert Undo Log`和`Update Undo Log`

##### 3.2.1 Insert Undo Log

在Insert操作中产生的Undo日志。Insert操作的记录只对事务本身可见，其他事务是不可见的。Insert Undo Log可以在事务提交后直接删除而不需要进行回收。

##### 3.2.1 Update Undo Log

在Update或Delete操作中产生的Undo日志。Update操作会对已经存在的行记录产生影响，为了实现MVCC，Update Undo日志不能在事务提交时就删除，而是在事务提交时将日志存入UndoLog链表中，等待Purge线程进行最后的删除操作。

#### 3.3 Read View

##### 3.3.1 ReadView

ReadView是张存储事务Id的列表，主要包含当前系统中有哪些活跃的读写事务id，结合Undo日志的默认字段`trx_id`来控制哪个版本的Undo日志可被其他事务看见。

四个列：

- m_ids：生成ReadView时，当前活跃的事务id列表
- m_low_limit_id：事务id下限，当前活跃事务中最小的事务id
- m_up_limit_id：事务id上限，生成ReadView时，应该分配给下一个事务的id值
- m_creator_trx_id：生成该ReadView的事务的事务id

##### 3.3.1 生成时机

- 开启事务后，在第一次查询时，生成ReadView
- `RC`和`RR`隔离级别的差异本质因为MVCC中ReadView的生成时机不同。
  - RC，在每次查询开始时都会生成一个独立的ReadView
  - RR，只会在第一次执行查询语句时生成一个ReadView，之后的查询就不会重复生成。
  - RU总是读最新，本身没有隔离性，不需要MVCC；串行化对所有读都加锁，线程之间隔离，不需要MVCC。 

##### 3.3.2 判断可见性

开启事务第一次查询时，生成ReadView，然后根据Undo日志和ReadView判断可见性。

判断规则：

- trx_id 小于 m_low_limit_id，可以被当前事务访问。因为生成该版本的事务在生成ReadView前已经提交。
- trx_id 等于 m_create_trx_id，可以被当前事务访问。
- trx_id 大于等于 m_up_limit_id，不可以被当前事务访问。因为生成ReadView后才产生的数据。
- trx_id 在low和up之间，需要判断是否在m_ids列表中
  - 如果在，不可以访问。因为创建ReadView时生成该版本的事务还是活跃的。
  - 如果不在，可以被访问。因为创建ReadView时生成该版本的事务已经被提交。

#### 3.4 读操作

MVCC中，读操作分为：快照读（Snapshot Read）和当前读（Current Read）

- 快照读：读不加锁，读取的是版本链的快照数据，默认的读都是快照读。

  ```mysql
  select * from table where id =1;  # 不加锁
  ```

- 当前读：读取的永远都是最新数据，保证其他事务不会再并发修改这条记录。

  ```mysql
  select * from table where id =1 lock in share mode;	#加读锁（s锁）
  select * from table where id =1 for update;	#加写锁（X锁）
  insert update delete #加写锁（X锁）
  ```

update语句执行过程

- 首先，MySQL Server会根据where条件，读取第一天满足条件的记录，然后InnoDB会将第一条记录返回，并加锁。
- MySQL Server收到这条加锁的记录后，会再发起一个Update请求，更新这条记录。
- 一条记录操作完成，再读取下一条记录，直到没有满足条件的记录为止。因此，update操作内部包含一个当前读。

