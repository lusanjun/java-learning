## MySQL架构

### 1. MySQL架构图

![MySQL架构](https://gitee.com/lusanjun/blog-img/raw/master/img/MySQL.png)

### 2. 四层体系架构

#### 2.1 网络连接层

网络连接层位于整个MySQL体系架构的最上层，主要担任客户端连接器的角色。提供与MySQL服务器建立连接的能力，几乎支持所有主流的服务端语言，例如：Java、C、C++、Python等，各语言都是通过各自的API接口与MySQL建立连接。

#### 2.2 数据库服务层

数据库服务层是整个数据库服务器的核心，主要包括了系统管理和控制工具、连接池、SQL接口、解析器、查询优化器和缓存等部分。

- 连接池：主要负责存储和管理客户端与数据库的连接信息，连接池里的一个线程负责管理一个客户端到数据库的连接信息。
- 系统管理和控制工具：提供数据库系统的管理和控制功能，例如对数据库中的数据进行备份和恢复，保证整个数据库的安全性，提供安全管理，对整个数据库的集群进行协调和管理等。
- SQL接口：主要负责接收客户端发送过来的各种SQL命令，并将SQL命令发送到其他部分，并接收其他部分返回的结果数据，将结果数据返回给客户端。
- 解析器：主要负责对请求的SQL解析成一棵“解析树”，然后根据MySQL中的一些规则对“解析树”做进一步的语法验证，确认其是否合法。
- 查询优化器：在MySQL中，如果“解析树”通过了解析器的语法检查，此时就会由优化器将其转化为执行计划，然后与存储引擎进行交互，通过存储引擎与底层的数据文件进行交互。
- 缓存：MySQL的缓存是由一系列的小缓存组成的。例如：MySQL的表缓存，记录缓存，MySQL中的权限缓存，引擎缓存等。MySQL中的缓存能够提高数据的查询性能，如果查询的结果能够命中缓存，则MySQL会直接返回缓存中的结果信息。缓存在8.0+中已移除。

#### 2.3 存储引擎层

MySQL中的存储引擎层主要负责数据的写入和读取，与底层的文件进行交互。MySQL中，最常用的存储引擎就是InnoDB和MyISAM。

#### 2.4 系统文件层

系统文件层主要包括MySQL中存储数据的底层文件，与上层的存储引擎进行交互，是文件的物理存储层。其存储的文件主要有：日志文件、数据文件、配置文件、MySQL的进行pid文件和socket文件等。

- 日志文件：主要包括：错误日志、通用查询日志、二进制日志、慢查询日志等。
- 数据文件：主要包括：db.opt文件、frm文件、MYD文件、MYI文件、ibd文件、ibdata文件、ibdata1文件、ib_logfile0和ib_logfile1文件等。
  - db.opt文件：主要记录当前数据库使用的字符集和检验规则等信息。
  - frm文件：存储数据表的结构信息，主要是数据表相关的元数据信息，包括数据表的表结构定义信息，每张表都会有一个frm文件。
  - MYD文件：MyISAM存储引擎专用的文件格式，主要存放MyISAM存储引擎数据表中的数据，每张MyISAM存储引擎表对应一个.MYD文件。
  - MYI文件：MyISAM存储引擎专用的文件格式，主要存放与MyISAM存储引擎数据表相关的索引信息，每张MyISAM存储引擎表对应一个.MYI文件。
  - ibd文件：存放Innodb存储引擎的数据文件和索引文件，主要存放的是独享表空间的数据和索引，每张表对应一个.ibd文件。
  - ibdata文件：存放Innodb存储引擎的数据文件和索引文件，主要存放的是共享表空间的数据和索引，所有表共用一个（或者多个）.ibdata文件，可以根据配置来指定共用的.ibdata文件个数。
  - ibdata1文件：MySQL的系统表空间数据文件，主要存储MySQL的数据表元数据、Undo日志等信息。
  - ib_logfile0和ib_logfile1文件：MySQL数据库中的Redo log文件，主要用于MySQL实现事务的持久性。如果在某个时间点MySQL发生了故障，此时如果有脏页没有写入到数据库的ibd文件中，在重启MySQL的时候，MySQL会根据Redo Log信息进行重做，将写入Redo Log并且尚未写入数据表的数据进行持久化操作。
- 配置文件：用于存在MySQL所有的配置信息，在Unix/Linux环境中是my,cnf文件，在Windows环境中是my.ini文件。

### 3. 日志文件

#### 3.1 错误日志

error log，默认开启，记录运行过程中遇到的所有严重的错误信息。配置项：

- log_error：指定错误日志存储位置
- log_warnings：是否将警告信息输出到错误日志中
  - 0：不记录告警信息
  - 1：告警信息写入错误日志
  - 大于1：各类告警信息

```properties
log_error=/var/log/mysql-error.log
log_warnings=2
```

#### 3.2 二进制日志

bin log，默认关闭，记录数据库所有的ddl语句和dml语句，不包括select语句内容，语句以事件的形式保存，描述了数据的变更顺序。

dml语句必须通过事务提交才能记录到bin log。

bin  log 主要用于实现mysql主从复制、数据备份、数据恢复。

#### 3.3 慢查询日志

slow query log，默认关闭，记录执行时间超过`long_query_time`秒的所有查询，便于收集查询时间长的SQL语句。

```shell
show global status like '%Slow_queries%';
show variables like '%slow_query%';
show variables like 'long_query_time%';
```

配置慢查询开启

```properties
# 开启慢查询日志
slow_query_log=ON
# 慢查询的阈值，单位秒
long_query_time=10
# 日志记录文件
# 如果没有给出file_name值， 默认为主机名，后缀为-slow.log。
# 如果给出了文件名，但不是绝对路径名，文件则写入数据目录。
slow_query_log_file=slow_query_log.log
```

### 4.  数据文件

查看MySQL数据文件

```shell
show variables like '%datadir%';
```

ibdata文件：使用系统表空间存储表数据和索引信息，所有表共同使用一个或多个ibdata文件。

InnoDB引擎的数据文件：

- .frm文件：存放于表相关的数据信息，主要包括表结构的定义信息。 8.0+版本后合并到ibd文件。
- .ibd文件：表数据和所有信息，一张表对应一个ibd文件。

MyISAM引擎的数据文件：

- .frm文件：存放于表相关的数据信息，主要包括表结构的定义信息。8.0+版本改为sdi文件。
- .myd文件：存放数据
- .myi文件：存放索引

### 5.一条SQL语句的执行流程

```sql
select id ,name, age from user where id = 3;
```

#### 5.1 连接到数据库

连接器连接到数据库。连接完成后，如果没有后续动作，连接空闲。长时间空闲，就会自动断开。最长时间默认8小时。

#### 5.2 查询缓存

拿到查询请求，会先查询缓存。之前执行过的语句及结果会被缓存在内存中。如果在缓存中，直接返回客户端。不在缓存，执行后面的流程。不建议使用内置的缓存功能。原因：

- 成本高：查询缓存的失效频繁，只要有对一个表的更新，缓存就清空。
- 命中率不高：频繁更新的表，缓存命中率很低，除非是静态表，很长时间都不更新。
- 功能不如专业缓存工具好：redis、memcache

#### 5.3 分析SQL语句

sql语句是一个字符串，MySQL服务器分析判断sql请求的语法是否正确，从语句中将查询的表、列和条件提取出来。

##### 5.3.1 词法分析

把一个完整的sql语句分割成一个个字符串。

```mysql
# 分割前
select id ,name, age from user where id = 3;
# 分割后
select, id ,name, age, from, user, where, id, = ,3
```

分析字符串代表什么

- select 代表这是一个查询语句
- user代表表名
- id,name,age 代表列

##### 5.3.2 语法分析

语法分析器判断语句是否满足MySQL语法，正确会生成一个数据结构——解析树。

> ”You have an error in your SQL syntax”错误提醒就是在这个位置出现

##### 5.3.3 预处理器

预处理器进一步检查解析树是否合法，比如表名是否存在，列是否存在。MySQL检查用户是否有表操作权限。

##### 5.3.4 优化SQL语句

根据解析树生成不同的执行计划，选择最优的执行计划。

- 当有多个索引可用的时候，决定使用哪个索引；
- 在一个语句有多表关联时，决定各个表的连接顺序，以哪个表为基准。

##### 5.3.5 执行SQL语句

判断执行权限：先判断用户对表有没有执行查询的权限。

调用存储引擎接口查询，使用指定的存储引擎打开表开始查询。执行器根据表的引擎定义，去使用这个引擎提取数据。

### 6. InnoDB存储引擎

#### 6.1 存储引擎种类

| 存储引擎 | 说明                               |
| -------- | ---------------------------------- |
| MyISAM   | 高速引擎，查快，不支持事务         |
| InnoDB   | 支持事务和行级锁                   |
| Memory   | 内存存储，极快的效率。数据会丢失。 |
| Archive  | 压缩数据进行存储，只能插入和查询。 |

#### 6.2 MyISAM和InnoDB区别

| 比较项   | Innodb                                  | MyISAM                                      |
| -------- | --------------------------------------- | ------------------------------------------- |
| 存储文件 | .frm 表定义文件 .ibd 数据文件和索引文件 | .frm 表定义文件 .myd 数据文件 .myi 索引文件 |
| 锁       | 表锁、行锁                              | 表锁                                        |
| 事务     | 支持                                    | 不支持                                      |
| CRUD     | 读、写                                  | 读多                                        |
| 索引结构 | B+ Tree                                 | B+ Tree                                     |

#### 6.3 内存结构

![InnoDB](https://gitee.com/lusanjun/blog-img/raw/master/img/InnoDB.png)

##### 6.3.1 缓冲池(Buffer Pool)

缓冲池用于加速数据的访问和修改，将热点数据缓存在内存，减少磁盘IO，加速热点数据读写。

- 默认大小128M
- 使用LRU（Least Recently-Used 最近最少使用）淘汰非热点数据页
- 数据以页为存储单位，数据结构是单链表

##### 6.3.2 修改缓冲(Change Buffer)

- 修改缓冲用于加速非热点数据中二级索引的写入操作。
- 对二级索引的修改操作会录入redo log中。
- 缓冲到一定量或系统较空闲时进行merge操作。
- 在系统表空间中有相应的持久化区域。
- 大小默认占Buffer Pool的25%，最大50%。
- 物理结构为一棵名为`ibuf`的B Tree

二级索引就是辅助索引，除了聚簇索引之外的所有索引都是二级索引。

聚簇索引也叫聚集索引，指数据与索引的数据结构存储在一起。

##### 6.3.3 自适应哈希索引(AHI)

自适应哈希索引（Adaptive Hash Index）用于实现对于热数据页的一次查询。是建立在索引之上的索引。

作用：对频繁查询的数据页和索引页进一步提速。

AHI大小为Buffer Pool 的 1/64

若二级索引命中AHI，从AHI获取索引页记录指针，再根据主键沿着聚簇索引查找数据。

若聚簇索引命中AHI，直接返回目标数据页的记录指针，根据记录指针可以直接定位数据页。

##### 6.3.4 日志缓冲(Log Buffer)

- 缓冲日志文件的写入操作
- 内存写入加上日志文件顺序写，使日志写入性能高

#### 6.4 磁盘表空间

InnoDB将数据、索引、表结构和其他缓存信息等存放的空间称为表空间。由段Segme、区Extent、页Page、行Row组成。

##### 6.4.1 系统表空间

系统表空间（System Tablespace）是InnoDB数据字典、双写缓冲、修改缓冲和回滚日志的存储空间。

- 数据字典：表对象的元数据信息（表结构、索引、列信息）
- 双写缓冲：保证写入数据时页数据的完整性，防止部分写失效等问题
- 修改缓冲：内存中 Change Buffer 对应的持久化区
- 回滚日志：实现数据回滚时对数据的恢复，MVCC实现的重要组成

默认大小12M，文件名称ibdata1。

系统表空间会自动增长，每次增量64MB，且增长后的文件不可缩减。

##### 6.4.2 独立表空间

独立表空间（File-per-table Tablespace）用于存放每个表的数据和索引，初始化大小96KB

其他类型的信息，如：回滚日志、双写缓冲区、系统事务信息、修改缓冲等仍存放于系统表空间。

数据库文件夹内，为每张表单独创建`table_name.ibd`文件存放数据和索引，`table_name.frm`文件存放表结构信息。

##### 6.4.3 通用表空间

通用表空间（General Tablespace）为了在系统表空间与独立表空间之间做出平衡。

系统表空间与独立表空间中的表可以向通用表空间移动，反之亦可。

系统表空间中的表无法直接与独立表空间中的表相互转化。

##### 6.4.4 回滚表空间

回滚表空间（Undo Tablespace）用于存放一个或多个 undo log 文件，默认大小10MB

undo log 默认存储在系统表空间，5.7版本后支持自定义到独立的表空间

##### 6.4.5 临时表空间

5.7版本后，从系统表空间中抽离出临时表空间（Temporary Tablespace），用于独立保存临时表数据及其回滚信息。

#### 6.5 磁盘存储结构

##### 6.5.1 段

表空间由各个段（Segment）构成，段类型分为数据段（Leaf node segment）、索引段（Non-Leaf node segment）、回滚段等。

一个段包含多个区，至少有一个区，段扩展的最小单位是区。

##### 6.5.2 区

区（Extend）由连续的页组成，大小固定1MB

默认情况下，一个区有64个页

为了保证页的连续性，InnoDB 存储引擎会一次从磁盘申请 4 ~ 5 个区。  

##### 6.5.3 页

页（Page）是InnoDB的基本存储单位，页默认大小16K。设置大小必须是4的倍数，因为操作系统读写磁盘最小单位是页，大小是4K。

##### 6.5.4 行

InnoDB的数据是以行（Row）为单位存储，一个页中包含多个行

4种行格式：Compact、Redundant、Dynamic和Compressed

默认行格式Dynamic

#### 6.6 内存数据落盘

##### 6.6.1 内存数据落盘的问题

- 提高性能：内存中写，操作过程记录日志，日志定期批量写入磁盘，减少磁盘IO
- 持久化：
  - 通过 `CheckPoint`机制进行脏页落盘
  - 日志先行，所有操作前先写Redo日志
- 安全性：
  - Force Log at Commit
  - Write Ahead Log
  - CheckPoint
  - Double Write

##### 6.6.1 脏页落盘

对数据的修改操作，首先修改内存结构中缓冲区的页，缓冲区的页与磁盘的页数据不一致，所以缓冲区的页称为脏页。

脏页从缓冲区刷新到磁盘，不是每次页更新之后触发，而是通过`CheckPoint`机制刷新磁盘。

每次更新直接写入磁盘的问题：

- 如果每次一个页发生变化就进行落盘，每次落盘一个页，必然有4次IO操作，性能开销大
- 如果数据长期在内存中保存，数据就存在安全性风险
- InnoDB采用Write Ahead Log 策略和Force Log at Commit机制实现事务级别下数据的持久性:
  - Force Log at Commit机制：事务提交时，所有事务产生的日志都必须刷到磁盘
  - Write Ahead Log（WAL）策略：数据变更写入到磁盘前，首先将内存中的日志写入磁盘。InnoDB是redo log，对于写操作，永远是日志先行，先写入redo log 确保一致性后，再对修改数据进行落盘。

##### 6.6.2 Redo日志落盘

##### 6.6.3 CheckPoint机制

CheckPoint是将缓冲池中的脏页数据刷到磁盘上的机制，决定脏页落盘的时机、条件和脏页的选择等

解决问题：

- 脏页落盘：避免数据更改直接操作磁盘
- 缩短数据库的恢复时间：数据库宕机，不需要重做所有日志，因为CheckPoint之前的页都已经刷新回磁盘，数据库只需对CheckPoint后的redo日志进行恢复。
- 缓冲池不够用时，将脏页刷新到磁盘：缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页是脏页，需要强制执行CheckPoint，将脏页刷回磁盘。
- redo日志不可用时，刷新脏页：当redo日志出现不可用时，CheckPoint将缓冲池中的页至少刷新到当前redo日志的位置

CheckPoint分类

- sharp checkpotin：关闭数据库时，将buffer pool的脏页全部刷新到磁盘中
- fuzzy checkpoint：默认方式。只刷新一部分脏页，不是刷新所有
  - Master Thread CheckPoint：在Master Thread中，会以每秒或每10秒一次的频率，将部分脏页从内存中刷新到磁盘，这个过程是异步的。
  - FLUSH_LRU_LIST Checkpoint：缓冲池不够用时，根据LRU算法会淘汰掉最近最少使用的页，如果该页是脏页的话，会强制执行CheckPoint，将该脏页刷回磁盘。
  - Async/Sync Flush Checkpoint：重做日志不可用的情况，需要强制从脏页列表中选取一些脏页刷盘。
  - Dirty Page too much：脏页数量太多，导致强制进行Checkpoint。

##### 6.6.4 Double Write双写

脏页落盘出现的问题：写失效。数据库准备刷新脏页时，将16KB刷入磁盘，当写入8K，宕机了，称为写失效（partial page write）。

解决方案：上备胎。在redo日志前，对需要写入的页做副本，写失效时，通过页的副本还原该页再重做，就是double write。写失效后redo日志也是无法进行恢复的，因为redo日志记录的是对页的物理修改。

双写刷新脏页的流程：

- 首先复制：脏页刷新时不直接写磁盘，而是先将脏页复制到内存的Doublewrite buffer
- 再顺序写：内存的Doublewrite buffer 分两次，每次1MB顺序地写入共享表空间的物理磁盘上，会立即调用fsync函数同步OS缓冲到磁盘中，顺序写性能好
- 最后离散写：内存的Doublewrite buffer最后将页写入各自表空间文件中，离散写较顺序写入差一些





