## 面向对象



面向对象编程（OOP）。对象，一切都是对象，对象具有属性和行为，具有变化的状态。

Java中，对象是某个类别的实例。

面向对象和面向过程的区别：

- 面向过程强调的是功能行为、功能的执行过程，即先后顺序。每一个功能都使用方法按步骤一步步实现。缺点：随着系统膨胀，系统适应性差，可扩展性差，维护性不好。
- 面向对象可重用性好，可以实现高内聚和低耦合。

### 1. 继承

#### 1.1 继承

继承，子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

final 可以把类定义成不能继承的。

继承的特性：

- 子类拥有父类非 private 的属性、方法。
- 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
- 子类可以用自己的方式实现父类的方法。
- Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。
- 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。

#### 1.2 重写与重载

重写：Override，子类实现了一个与父类在方法声明上完全相同的一个方法。子类方法的访问权限必须大于等于父类方法；子类方法的返回类型必须是父类方法返回类型或为其子类型。子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。

重载：OverLoad，同一个类中，一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。返回值不同，其它都相同不算是重载。

#### 1.3 super

可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。

如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。

### 2. 封装

#### 2.1 封装

封装，一个对象的属性隐藏在对象内部，不允许外部对象直接访问，但是可以提供一些可以被外界访问的方法来操作属性。

封装的特性：

- 良好的封装能够减少耦合。
- 类内部的结构可以自由修改。
- 可以对成员变量进行更精确的控制。
- 隐藏信息，实现细节。

#### 2.2 访问控制修饰符

| 修饰符    | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包) | 其他包 |
| --------- | ------ | -------- | -------------- | -------------- | ------ |
| public    | Y      | Y        | Y              | Y              | Y      |
| protected | Y      | Y        | Y              | Y/N            | N      |
| default   | Y      | Y        | Y              | N              | N      |
| private   | Y      | N        | N              | N              | N      |

子类与基类在同一包中，被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；

子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的 protected 方法。

接口及接口的成员变量和成员方法不能声明为 protected。

#### 2.3 this

this 代表当前对象。this.属性，操作当前对象的属性。this.方法，调用当前对象的方法。

封装对象的属性时，经常用的 this 关键字。

#### 2.4 内部类

内部类（ Inner Class ）就是定义在另外一个类里面的类。与之对应，包含内部类的类被称为外部类。

每个内部类都能独立地继承一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。

内部类的作用：

- 内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外部对象信息相互独立。
- 单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。
- 提供更好的封装，可以把内部类隐藏在外部类中，不允许同一个包中的其他类访问。
- 内部类的方法可以直接调用外部类的所有数据，包括私有数据。

### 3. 多态

#### 3.1 多态

多态，一个对象具有多种状态，具体表现为父类的引用指向子类的实例。

多态的好处：

- 可替换性：多态对已经存在代码具有可替换性。
- 可扩充性：增加新的子类不影响已存在类的多态性、继承性。
- 接口性：多态是超类通过方法签名，向子类提供一个共同接口，由子类来完善或覆盖。
- 灵活性：应用中可以灵活操作。
- 简化性：简化了对应用程序的代码编写和修改过程。

#### 3.2 体现方面

引用多态：父类的引用可以指向本类的对象，也可以指向子类的对象。

方法多态：创建本类对象时，调用的方法是本类方法；创建子类对象时，调用的方法为子类重写或继承的方法。

#### 3.3 引用类型转换

向上转换：小类型转大类型。自动类型转换。

```java
 Cat cat = new Cat();
 Animal animal = cat;
```

向下转换：大类型转小类型，强制类型转换，有风险，可能会编译错误。

```java
 Cat cat = new Cat();
 Animal animal = cat;
 Cat cat2 = (Cat)animal;
```

### 4. 关键字

#### 4.1 final

修饰类，类不允许被继承。

修饰方法，该方法不允许被子类重写。private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。

修饰属性，此类的该属性不会进行隐式的初始化，final 属性的初始化属性必须有值，或在构造方法中赋值。

修饰变量，对于基本类型，final 使数值不变；对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。

```java
 final int x = 1;
 // x = 2;  // cannot assign value to final variable 'x'
 final A aa = new A();
 aa.x = 1;
```

#### 4.2 static

静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。

实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。

```java
 public class A {
     private int x;         // 实例变量
     private static int y;  // 静态变量
     public static void main(String[] args) {
         // int x = A.x;  // Non-static field 'x' cannot be referenced from a static context
         A a = new A();
         int x = a.x;
         int y = A.y;
     }
 }
```

静态方法：静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。

```java
 public abstract class A {
     public static void func1(){
     }
     // public abstract static void func2();  // Illegal combination of modifiers: 'abstract' and 'static'
 }
```

静态语句块：静态语句块在类初始化时运行一次。

```java
 public class A {
     static {
         System.out.println("123");
     }
 
     public static void main(String[] args) {
         A a1 = new A();
         A a2 = new A();
     }
 }
 //输出结果
 123
```

类初始化顺序：

对于静态变量、静态语句块、实例变量、普通语句块、构造器，它们的初始化顺序依次是（静态变量、静态语句块）>（实例变量、普通语句块）>构造器。

存在继承的情况下，初始化顺序为：父类（静态变量、静态语句块）> 子类（静态变量、静态语句块）> 父类（实例变量、普通语句块）> 父类（构造函数）> 子类（实例变量、普通语句块）> 子类（构造函数）

#### 4.3 transient

transient 修饰的变量不参与序列化。

该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。

### 5. 构造方法

用来完成对象的初始化。

没有声明构造方法的类也可以初始化，会默认带一个无参构造方法。如果手动添加了构造方法，则默认不带。

构造方法特性：

- 名字与类名相同。
- 没有返回值，但不能用 void 声明构造函数。
- 生成类的对象时自动执行，无需调用。
- 不能被重写，可以重载，有多个不同参数的构造方法。

### 6. 成员变量和局部变量

区别：

- 在类中的位置不同：成员变量在类中方法外面；局部变量在方法或者代码块中，或者方法的参数中。
- 在内存的位置不同：成员变量在堆中；局部变量在栈中。
- 生命周期不同：成员变量是对象的一部分，它随着对象的创建而存在；局部变量随方法调用结束而消失。
- 初始值不同：成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值；局部变量没有默认初始值，必须手动赋值。
- 语法形式不同：成员变量可以被 public 、private、static等修饰符修饰；局部变量不能访问修饰符和 static 修饰，但都可以被 final 修饰。

### 7. 内部类

#### 7.1 静态内部类

 定义在类内部的静态类被称为静态内部类。静态内部类可以访问外部类的静态变量和方法。在静态内部类中可以定义静态变量、方法、构造函数等。静态内部类通过“外部类.静态内部类”的方式来调用。

HashMap在内部维护了一个静态内部类Node数组用于存放元素，但Node数组对使用者是透明的，像这种和外部类关系密切且不依赖外部类实现的类，可以使用静态内部类实现。

#### 7.2 成员内部类

定义在类内部的非静态类称作成员内部类，成员内部类不能定义静态方法和变量。

#### 7.3 局部内部类

定义在方法中的类叫局部内部类，当一个类只需要在某个方法中使用某个特定的类时，可以通过局部类来实现。

#### 7.4 匿名内部类

匿名内部类指通过继承一个父类或者实现一个接口的方式直接定义并使用的类。匿名内部类没有class关键字，这是因为匿名内部类直接使用new生成一个对象的引用。