## JVM内存区域



### 1. 运行时内存区域

![JVMRuntimeArea](https://gitee.com/lusanjun/blog-img/raw/master/JVMRuntimeArea.png)

线程私有区域的生命周期与线程相同，随线程的启动而创建，随线程的结束而销毁。

线程共享区域随虚拟机的启动而创建，随虚拟机的关闭而销毁。

#### 1.1 程序计数器

程序计数器，可以看作是当前线程所指向的字节码的行号指示器。

字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要指向的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能需要依赖这个计数器来完成。

每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。

如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行 Native 方法，计数器值为空（Undefined）。

此内存区域不会有内存溢出情况（OutOfMemoryError）。

#### 1.2 Java虚拟机栈

Java 虚拟机栈（ JVM Stack ）是线程私有的，它的生命周期与线程相同。

Java 虚拟机栈描述的是 Java 方法执行的内存模型，每个方法执行的同时会创建一个栈帧。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常。如果虚拟机栈扩展时无法申请到足够的内存，将抛出 OutOfMemoryError 异常。

栈的优点，存取速度比堆块，仅次于寄存器。缺点，存在栈中的数据大小、生存期是在编译期决定的，缺乏灵活性。

一般程序员口中说的“栈”，通常就是指虚拟机栈，或者更多情况下指的是虚拟机栈中的局部变量表。

#### 1.3 本地方法栈

与虚拟机栈相似，主要为使用本地（Native）方法服务。

本地方法栈也会在栈深度溢出抛出 StackOverflowError ，或者栈扩展失败时抛出 OutOfMemoryError 异常。

#### 1.4 Java堆

Java堆（Java heap）是虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的是存放对象实例。

堆是垃圾收集器管理的主要区域，可分为：新生代（Eden、From Survivor、To Survivor）、老年代。仅对于算法而言，物理上不分代。

堆可以处于物理不连续的内存空间，但在逻辑上应该被视为连续的。

堆的优点，运行期动态分配内存大小，自动进行垃圾回收。缺点，效率相对低。

堆可以被实现成固定大小，也可以是扩展的。如果 Java 堆中没有完成实例分配，也无法再扩展时，会抛出 OutOfMemoryError 异常。

#### 1.5 方法区

方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，用于存储已被加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

JDK8以前，方法区中有“永久代”的概念，但仅仅是当时的 HotSpot 虚拟机选择把收集器的分代设计扩展至方法区，但是其他虚拟机实现，是不存在永久代的概念的。JDK7 的 HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，到了 JDK８，完全废弃了永久代的概念，用元空间（Metaspace）来代替。

元空间使用本地内存，永久代使用的是 jvm 的内存，替代后，java.lang.OutOfMemoryError:PermGen space 异常，将不会再出现。

元空间相比永久代的优势：

- 字符串常量池存在永久代中，容易出现性能问题和内存溢出；
- 类和方法的信息大小难以确定，给永久代的大小指定带来困难；
- 永久代会为GC代理不必要的复杂性；
- 方便 HotSpot 与其他 JVM 如 Jrockit 的集成。

#### 1.6 运行时常量池

运行时常量池（ Runtime Constant Pool）是方法区的一部分。

Class 文件中的常量池表（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分在类加载后存放到方法区的运行时常量池中。

常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。

### 2. Java堆

Java堆（Java heap）用来存放应用系统创建的对象和数组，所有线程共享Java堆。

#### 2.1 堆结构

新生代用来存放新分配的对象。新生代经过垃圾回收，没有回收掉的对象，被复制到老年代。

老年代存储对象比新生代存储对象的年龄大得多。

老年代存储一些大对象。

![Heap](https://gitee.com/lusanjun/blog-img/raw/master/Heap.png)

### 2. 内存中的对象

#### 2.1 对象的创建

当 JVM 遇到一条字节码 new 指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，如果没有则执行类加载过程。

类加载检查通过后，为新生对象分配内存。

内存分配完成之后，将分配到的内存空间都初始化为零值。

对象进行必要的设置，将这些信息存放在对象的对象头中。

new 指令之后接着执行 `<init>() `方法，对象进行初始化。

#### 2.2 对象的内存布局

HotSpot 虚拟机里，对象在堆中的存储布局分为：对象头、实力数据和对齐填充。

##### 2.2.1 对象头

对象头（Mark Word）包括两类信息：

第一类是用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。

另一部分是类型指针，即对象指向它的类型元数据的指针，JVM 通过这个指针来确定该对象是哪个类的实例。

![MarkWord](https://gitee.com/lusanjun/blog-img/raw/master/MarkWord.png)

##### 2.2.2 实例数据

  实例数据（Instance Data） 是对象真正存储的有效信息，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。

##### 2.2.3 对齐填充

对齐填充（Padding），没有特别含义，仅是占位符的作用。HotSpot 要求对象起始地址必须是8字节整数倍，对象头部分正好是8字节的倍数，如果实例数据部分没有对齐，就需要对齐填充来补全。

#### 2.3 对象的访问定位

在JVM规范中只规定了 reference 数据类型是一个指向对象的引用，没有规定通过什么方式去定位、访问堆中对象的具体位置，由虚拟机厂商自行实现。目前分为使用句柄和直接指针两种。

##### 2.3.1 使用句柄

Java 堆中会划分一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。

好处是 reference 中存储的是稳定句柄地址，在对象被移动时指挥改变句柄中的实例数据指针，而 reference 本身不许需要被修改。

#### 2.3.2 直接指针

Java 堆中对象的内存布局必须考虑如何放置访问类型数据的相关信息，reference  中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。

好处是速度更快。HotSpot 目前采用的就是这种方式。

### 3. 内存参数配置（JDK9+）

#### 3.1 Trace 跟踪

打印 GC 的简要信息：

```shell
-Xlog:gc
```

打印 GC 详细信息：

```shell
-Xlog:gc*
```

指定 GC log 的位置，以文件输出

```shell
-Xlog:gc:<filename>.log
```

每一次 GC 后，都打印堆信息

```shell
-Xlog:gc+heap=debug
```

#### 3.2 堆参数

初始堆大小，默认物理内存的1/64。必须是1024整数倍且大于1MB。

```shell
-Xms=6m
```

最大堆大小，默认物理内存的1/4。必须是1024整数倍且大于2MB。

建议与初始堆相同，避免每次 GC 后调整堆大小。

```shell
-Xmx=10m
```

新生代大小，默认整个堆的3/8。

```shell
-Xmn=3m
```

老年代与新生代的比值，如果 xms=xmx，且设置了 xmn 的情况下，该参数不用设置

```java
-XX:NewRatio
```

Eden区与 Survivor 区的大小比值，设置为8，则两个 Survivor 区与一个 Eden 区的比值为 2:8，一个 Survivor 占整个新生区的 1/10

```java
-XX:SurvivorRatio
```

#### 3.3 栈参数

函数调用深度，通常只有几百 K

```java
-Xss
```

#### 3.4 元数据空间参数

初始空间大小

```java
-XX:MetaspaceSize
```

最大空间，默认是没有限制的

```java
-XX:MaxMetaspaceSize
```

GC之后，最小的 MetaSpace 剩余空间容量的百分比

```java
-XX:MinMetaspaceFreeRatio
```