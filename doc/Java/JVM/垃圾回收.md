## 垃圾回收



### 1. 垃圾判断算法

#### 1.1 引用计数算法

引用计数算法（Reference Counting），在对象中添加一个引用计数器，每当引用计数器值加1；引用失效，计数器值减1；计数器值为0的对象不可能再被引用。

优点：实现简单、执行效率高，程序执行受影响较小；

缺点：过于简单需要配合大量的额外处理、无法检测出循环引用的情况。

#### 1.2 可达性分析算法

可达性分析（Reachability Analysis）算法是通过一系列称为”GC Roots“的根对象为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为”引用链“，如果某个对象到 GC Roots 间没有任何引用链相连，或者说从 GC Roots 到这个对象不可达，则证明此对象是不可能再被引用的。

可作为GC Roots的对象：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象；
- 在方法区中类静态属性引用的对象；
- 在方法区中常量引用的对象；
- 在本地方法栈中Native方法引用的对象；
- 所有被同步锁（synchronized）持有的对象；
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，常驻的异常对象，系统类加载器等。

#### 1.3 引用分类

JDK1.2之前传统的引用的定义：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用。

JDK1.2之后，引用分为：

- 强引用（Strongly Reference）：传统的引用的定义，是指在程序代码中普遍存在的引用赋值。无论任何情况下，垃圾收集器永远不会回收强引用的对象。
- 软引用（Soft Reference）：用来描述一些还有用，但非必须的对象。只被软引用关联的对象，在内存溢出前，会把这些对象列进回收范围进行二次回收，如果这次回收还没有足够内存，就会抛出内存溢出异常。
- 弱引用（Weak Reference）：用来描述哪些非必须对象，但是强度比软引用更弱一些。被弱引用关联的对象只能生成到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论内存是否足够，都会被回收。
- 虚引用（Phantom Reference）：最弱的一种引用关系。无法通过虚引用来取得一个对象实例，设置虚引用的唯一目的只是为了能在这个对象被回收时收到一个系统通知。JDK1.2 之后提供了 PhantomReference 类来实现虚引用。

#### 1.4 finalize

即使在可达性分析算法中判断为不可达的对象，也不是非死不可 。

如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链， 会被第一次标记，随后进行一次筛选，判断该对象是否有必要执行 finalize 方法。

假如对象没有覆盖 finalize 方法，或者 finalize 方法已经被虚拟机调用过，就视为没有必要执行。

判断有必要执行 finalize 方法，会被放入一个 F-Queue 的队列中，并由 Finalizer 线程区执行 finalize 方法。如果对象在 finalize 中成功自救，就移除”即将回收“的集合。自救失败就真要被回收了。

自救就是自己与引用链上的任何一个小对象建立关系。

Java不建议使用 finalize 方法。

#### 1.5 回收方法区

JVM规范没有强制要求实现方法区的垃圾收集。因为方法区回收条件苛刻，性价比不高。

方法区回收主要是废弃常量和无用的类。

判断无用的类需要满足三个条件：

- 该类所有的实例都已经被回收；
- 加载该类的类加载器已经被回收；
- 该类对应的java.lang.Class对象没有任何地方被引用。

### 2. 垃圾收集算法

#### 2.1 分代收集理论

弱分代假说（Weak Generational Hypothesis），绝大多数对象都是朝生夕死的。

强分代假说（Strong Generational Hypothesis），熬过越多次垃圾收集过程的对象就越难以消亡。

一般都把 Java 堆划分为新生代（Young Generation）和老年代（Old Generation）两个区域。新生代中，每次 GC 都有大批对象死去，存活的少量对象，会逐步晋升到老年代中。

跨代引用假说（Intergenerational Reference Hypothesis），跨代引用相对于同代引用来说仅占极少数。隐含推论：存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。

STW（Stop-The-World）：Java中一种全局暂停现象，所有Java代码停止运行，native代码可以执行，但不能和JVM交互。危害是长时间服务停止，没有响应。应尽量减少STW。

#### 2.2 标记-清除算法

标记-清除算法（Mark-Sweep）：标记所有需要回收的对象，然后统一回收掉所有被标记的对象。

缺点：

- 执行效率不稳定：堆中大量对象都是需要被回收的，大量的标记和清除动作，导致效率降低。
- 内存碎片化问题：标记清除后会产生大量不连续的内存碎片，碎片太多可能会导致以后需要大内存的对象无法找到连续内存而不得不提前触发另一次垃圾回收。

#### 2.3 标记-复制算法

也简称为复制算法（Copy），将可用内存容量划分为大小相等的两块，每次使用一块，当这一块内存用完了，就将存活的对象复制到另一块上面，然后把使用过的内存空间一次清理掉。

优点：分配内存不用考虑空间碎片，只要移动堆顶指针，按顺序分配即可，实现简单，运行高效。适用于存活率低的新生代。

缺点：可使用空间缩小一半，浪费较多。对象存活率高时，效率降低。

JVM 实现中，是将内存分为较大的 Eden（8/10） 区和两块较小的 Survivor （1/10）区，每次使用 Eden 和一块 Survivor，回收时，把存货的对象复制到另一块 Survivor。

#### 2.4 标记-整理算法

标记-整理算法（Mark-Compact）：标记所有存活的对象，让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。

优点：避免空间碎片化，不用设置两块内存互换，适用于存活率高的老年代。

缺点：大量存活的对象的移动，效率极低。

#### 2.5 分代收集算法

![Heap](https://gitee.com/lusanjun/blog-img/raw/master/Heap.png)

只是上述综合的一个算法。

新生代（Young Generation）：用来存放新生的对象，一般占据堆内存的1/3。由于频繁创建对象，会频发触发MinorGC进行垃圾回收。又分为Eden区、Survivor From、Survivor To三个区。

- Eden区：伊甸园区，Java新对象的出生地。如果新创建的对象占有内存极大，直接分配到老年区。当Eden内存不够，就触发MinorGC，对新生代进行一次垃圾回收。
- Survivor From：上一次GC的幸存者，作为这一次GC的被扫描者。
- Survivor To：保留了一次MinorGC过程中的幸存者。

MinorGC的过程：主要采用复制算法。对象存活于Eden区和Survivor From区，Survivor To区是空的。GC开始，Eden区所有存活的对象复制到To区，From区中，仍存活的对象根据年龄值来决定去留，年龄值达到一定阈值（默认为15，可通过-XX:MaxTenuringThreshold来设置）的对象被移动到老年代中，没有达到阈值的对象复制到To区。复制一次，所有存活的对象的年龄值都加1。GC完成，Eden区和From区被清空，From和To交换角色，新From为原来的To。重复该过程，直到To区填满，所有存活的对象移动到老年代中。

老年代：存放生命周期较长的对象，或占有内存较大的对象。老年代空间不足，会触发Full GC。

Full GC 是对整个堆进行垃圾回收，执行速度很慢，对系统压力很大，可能会“stop-the-world"。

Full GC触发的条件：

- 老年代空间不足。
- 永久代空间不足：JDK1.8之前会有的情况。JDK1.8之后用元空间代替了永久代，不会再发生该情况。
- CMS GC时出现promotion failed,concurrent mode failure：promotion failed是在进行Minor GC时，survivor space放不下、对象只能放入老年代，而此时老年代也放不下造成的；concurrent mode failure是在执行CMS GC的同时有对象要放入老年代，而此时老年代空间不足造成的。
- Minor GC 晋升到老年代的平均大小大于老年代的剩余空间。
- 调用System.gc()：只是程序员建议而非系统一定会执行。最好是交给虚拟机自己管理。
- 使用RMI来进行RPC或管理的JDK应用，每小时执行1次Full GC。

### 3. HotSpot 算法实现

#### 3.1 OopMap

OopMap（Ordinary Object Pointer Map）是记录对象之间引用关系的一个数据结构。在类加载完成时，把对象内什么偏移量上是什么类型的数据计算出来，在即时编译中，也会把特定位置记录下栈里和寄存器里哪些位置是引用。真正到 GC 的时候可以直接读取，不用再从根节点一个个查找。

#### 3.2 安全点

HotSpot 没有为每条指令都生成 OopMap，在“特定位置”记录信息，这些位置称为安全点（Safepoint）。安全点位置基本上以“是否具有让程序长时间执行的特征”为标准选择的。

考虑的问题：如何在垃圾收集时让所有线程都跑到最近的安全点，然后停顿下来。

两种解决方案：：

- 抢先式中断（Preemptive Suspension），系统把所有线程全部中断，如果有线程不在安全点，就恢复这条线程执行，让它一会再中断，直到跑到安全点。现在几乎没有采用此方式。
- 主动式中断（Voluntary Suspension），不直接操作线程，只是设置一个标志位，各个线程执行过程中主动轮询这个标志，一旦发现标志为真就在最近的安全点主动中断挂起。

#### 3.3 安全区域

安全区域（Safe Region），指能够确保在某一段代码片段中，引用关系不会发生变化，在此区域任意地方开始垃圾收集都是安全的。

#### 3.4 记忆集与卡表

记忆集（Remembered Set），一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。把老年代划分成若干小块，标识出老年代的那一块会存在跨代引用，当发生 Minor GC，只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描。

记录精度：

- 字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如32位或64位，这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。
- 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。
- 卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。

第三种卡精度指的是一种“卡表”（Card Table）的方式。卡表是记忆集的一种具体实现，定义了记忆集的记录精度、与堆内存的映射关系等。

卡表的每个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”（Card Page）。卡页的大小是2的 N 次幂的字节数。

一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为变脏（Dirty），没有则标识为0。在垃圾收集时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入 GC Roots 中一并扫描。

#### 3.5 写屏障

HotSpot 通过“写屏障”（Write Barrier）技术维护卡表状态。

写屏障可以看作在虚拟机层面堆“引用类型字段赋值”这个动作的AOP切面。

在引用对象赋值时会产生一个环形（Around）通知。赋值的前后都在写屏障的覆盖范畴内。赋值前的写屏障叫写前屏障（Pre-Write Barrier），赋值后的叫写后屏障（Post-Write Barrier）。

### 4. 垃圾收集器

![GarbageCollectors](https://gitee.com/lusanjun/blog-img/raw/master/GarbageCollectors.png)

#### 4.1 串行收集器

Serial/Serial Old 收集器，单线程收集，必须 Stop-the-World 。但是停顿时间相对很短，用户可以接受。简单高效。

新生代默认Serial 收集器，使用复制算法。老年代默认Serial Old 收集器，使用标记-整理算法。

主要用于 Client 模式使用。

使用：-XX:+UseSerialGC开启

#### 4.2 并行收集器

ParNew 收集器是 Serial 收集器的多线程并行版本。是激活CMS后的默认新生代收集器。

在并发能力好的CPU环境里，停顿时间比串行短。单CPU或并发弱的CPU，比串行更差。

是 Server 模式下首选的新生代收集器，配合 CMS 使用。

#### 4.3 Parallel Scavenge/Parallel Old

更关注吞吐量（Throughput），能最高效率利用 CPU，并行收集的多线程收集器。
 Parallel Scavenge，新生代收集器，使用标记-复制算法。

Parallel Old，老年代收集器，使用标记-整理算法。

#### 4.4 CMS 收集器

 CMS（Concurrent Mark Sweep）收集器是并发低停顿的收集器。

CMS 使用标记-清除算法。工作过程：

1. 初始标记：stop the world，标记一下 GC Roots能直接关联到的对象，速度很快；
2. 并发标记：从 GC Roots的直接关联对象开始遍历整个对象图，耗时较长但是不需要停顿用户线程；
3. 重新标记：并发标记期间的增量更新，停顿时间比初始标记稍长；
4. 并发清除：清理删除掉标记阶段判断已经死亡的对象。可以与用户线程同时并发。

缺点：

- 对处理器资源非常敏感：并发阶段，因为占用了一部分线程而导致应用程序变慢，降低总吞吐量；
- 无法处理“浮动垃圾”：并发标记和并发清理阶段，用户线程还在继续运行，不断有新的垃圾生成。还需要预留足够内存空间提供给用户线程使用，必须预留一部分空间；
- 空间碎片化问题：基于“标记-清除”算法，收集结束后会有大量空间碎片。给大对象分配空间不得不提前触发一次 Full GC。

使用：-XX:UseConcMarkSweepGC，使用 ParNew + CMS + Serial Old 的收集器组合，Serial Old 作为CMS出错的后备选择。

#### 4.5 G1 收集器

Garbage First 收集器，面向服务端应用。特点：

- G1 把内存划分成多个独立的区域（Region）。
- G1 仍采用分代思想，但不再是物理隔离，而是一部分 Region 集合，且不需要连续。
- G1 能充分利用多 CPU，多核环境硬件优势，尽量缩短 STW。
- G1 整体上采用标记-整理算法，局部是使用复制算法，不会产生内存碎片。
- G1 的停顿可预测，能明确指定在一个时间段内，消耗在垃圾收集上的时间不能超过多长时间。
- G1 跟踪各个 Region 里面垃圾堆的价值大小，在后台维护一个优先列表，优先回收价值最大的区域。这就是 G1 收集器的 Mixed GC 模式。

工作过程：

1. 初始标记：标记一下 GC Roots能直接关联到的对象，停顿线程，耗时很短。
2. 并发标记：扫描堆里的对象图，找出要回收的对象，耗时较长，但可以并发执行。
3. 最终标记： 修正并发标记期间，因程序运行导致标记发生变化的那一部分对象。
4. 筛选回收：根据时间来进行价值最大化的回收。暂停用户线程，多条收集器线程并发完成。

#### 4.6 ZGC 收集器

JDK11加入的具有实验性质的低延迟收集器。

基于 Region 内存布局的，不设分代的，使用了读屏障、染色指针和内存多重映射等来实现可并发的标记-整理算法的，以低延迟为首要目标的一块垃圾收集器。

染色指针是一种直接将少量额外的信息存储在指针上的技术。Linux 下64位指针的高18位不能用来寻址，剩下的46位指针宽度，ZGC 将其高4位提取出来存储四个标志信息。

读屏障类似于写屏障，也相当于 AOP，当去堆上读取引用时会加上屏障，检查引用的状态，执行特定的工作。

#### 4.7 GC 性能指标

吞吐量 = 运行用户代码时间 / 运行用户代码时间 + 运行垃圾收集时间

GC 负荷 =  运行垃圾收集时间 / 运行用户代码时间 + 运行垃圾收集时间

暂停时间，stop-the-world 的总时间

GC 频率，GC 在一个时间段发生的次数

反应速度，从对象成为垃圾到被回收的时间

### 5. 内存配置原则

#### 5.1 新生代

新生代尽可能设置大点，太小会导致 Minor GC 频发出发和对象进入老年代触发 Full GC。

对象优先在 Eden 分配。

#### 5.2 老年代

综合考虑并发量和并发持续时间等参数。

针对吞吐量优先的应用：设置较大的新生代和较小的老年代。

大对象和长期存活的对象直接进入老年代。

#### 5.3 空间分配担保

当新生代进行垃圾回收后，新生代的存活区放置不下，那么需要把这些对象放置到老年代区，也就是老年代为新生代的 GC 做空间分配担保。步骤：

1. 在发生 Minor GC 之前，JVM先检查老年代的最大可用连续空间，是否大于新生代所有对象总空间。如果大于，可以确保 Minor GC 是安全的。

2. 如果不大于，JVM检查是否允许担保失败。

   如果允许，继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小。

3. 如果大于，则尝试一次 Minor GC，尽管是有风险的。

4. 如果小于，或者不允许冒险，就进行一次 FullGC。

这里的冒险指，极端情况下，新生代回收后，所有对象都存活，直接送入老年代。老年代作担保的前提是，老年代本身有容纳这些对象的剩余空间。