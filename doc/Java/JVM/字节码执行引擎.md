## 字节码执行引擎

不同的JVM实现中，执行字节码通常会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择。

所有的JVM的执行引擎，功能基本都是输入字节码二进制流，对字节码进行解析并处理，最后输出执行的结果。



### 1. 运行时栈帧结构

栈帧（Stack Frame）是用于支持JVM进行方法调用和方法执行的数据结构。

栈帧随着方法调用而创建，随着方法结束而销毁。

每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。

![StackFrame](https://gitee.com/lusanjun/blog-img/raw/master/StackFrame.png)

#### 1.1 局部变量表

局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在程序编译为Class文件时，就确定了该方法所需分配的局部变量表的最大容量。

局部变量表的容量以变量槽（Variable Slot）为最小单位。每个变量槽可以存放一个32位以内的数据类型，诸如boolean、byte、char、short、int、float、referencce 和 returnAddress 这8种类型。

对于64位长度的数据类型（double、long），虚拟机会以高位对齐的方式为其分配2个连续的变量槽，也就是把一次 long 和 double 数据类型读写分割为两次32位读写。

如果执行的是实例方法（没有被 static 修饰的方法），第0位变量槽存放的是 this ，然后从1到 n，依次分配给参数列表。然后根据方法体内部定义的变量顺序和作用域分配其余的变量槽。

变量槽可以重用，如果当前字节码 PC 计数器的值已经超出了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量来重用。优点是节省栈帧空间，缺点是可能会影响到系统的垃圾收集行为。

```java
//关于复用影响 gc
public static void main(String[] args){
    {
       byte[] bs = new byte[](1*1024*1024); 
       byte[] bs2 = new byte[](1*1024*1024);
    }
    int a = 1;
    System.gc;
}
//执行gc后，bs会被回收，而bs2不会。因为int a 复用了 bs的变量槽。
```

#### 1.2 操作数栈

操作数栈（Operand Stack）也被称为操作栈，它是一个后入先出（ Last In First Out）栈。最大深度也在编译时被写入到Code属性的max_stacks数据项中。

操作数栈的每个位置都可以保存一个java虚拟机中定义的任意数据类型，包括long和double。

当一个方法刚开始执行时，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，即出栈和入栈操作。

操作数栈中元素的数据类型必须与字节码指令的序列严格匹配。

在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的。但是在大多数虚拟机的实现里都会进行一些优化处理，令两个栈帧出现一部分重叠，让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，不仅节约了空间，更重要的是在进行方法调用时就可以直接共用一部分数据，无须进行额外的参数复制传递。

#### 1.3 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。

Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。另外一部分将在每一次运行期间都转化为直接引用，这部分被称为动态连接。

#### 1.4 方法返回地址

当一个方法开始执行后，只有两种方式退出这个方法：

- 执行引擎遇到任意一个方法返回的字节码指令，可能会有返回值传递给上层的方法调用者，方法是否有返回值以及返回值类型将根据遇到何种方法返回指令来决定，这种方式称为“正常调用完成”。主调方法的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。
- 当执行遇到异常，并且当前方法体内没有得到处理，就会导致方法退出，此时没有返回值，称为“异常调用完成”。返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存这部分信息。

方法退出的过程等同于当前栈帧出栈，退出可能执行的操作有：

- 恢复上层方法的局部变量表和操作数栈；
- 把返回值压入调用者栈帧的操作数栈中；
- 调整PC计数器的值以指向方法调用指令后面的一条指令。

### 2. 方法调用

方法调用就是确定具体调用哪一个方法，并不涉及方法内部的具体运行过程。

按照调用方式分为解析调用和分派调用。

#### 2.1 解析调用

解析（Resolution）是指，在类加载的解析阶段，会将其中一部分符号引用转化为直接引用。

成立的前提是：方法在程序运行之前就可以确定调用的版本，且在运行期是不可改变的。

符合这种方法调用的主要有静态方法和私有方法两大类。

JVM支持5条方法调用字节码指令：

- invokestatic：调用静态方法
- invokespecial：调用实例构造器 <init>()方法、私有方法和父类中的方法
- invokevirtual：调用所有的虚方法
- invokeinterface：调用接口方法，会在运行时再确定一个实现该接口的对象
- invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后执行该方法

只要能被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段确定唯一的调用版本。符合的有静态方法、私有方法、实例构造器、父类方法4种，在加上被 final 修饰的方法，这5种在加载时就解析的方法称为“非虚方法“（Non-Virtual Method），与之相反的是”虚方法“（Virtual Method）。

#### 2.2 分派调用

分派（Dispatch）调用会体现多态的一些特征。

##### 2.2.1 静态分派

所有依赖静态类型来决定方法执行版本的分派动作，称为静态分派。

典型应用表现就是方法重载。

重载版本并不是唯一的，只能确定一个”相对更合适”的版本。

```java
public class Overload{
    public static void sayHello(long arg){
        System.out.println("hello long");
    }
    public static void sayHello(int arg){
        System.out.println("hello int");
    }
    public static void sayHello(char arg){
        System.out.println("hello char");
    }
    public static void main(String[] args) {
    	sayHello('a');
    }  
}

//输出结果为 hello char
//注释掉sayHello(char arg)，输出结果为hello int
//注释掉sayHello(int arg)，输出结果为hello long
```

##### 2.2.2 动态分派

根据运行期的实际类型来定位方法执行版本的分派方式，称为动态分派。

典型应用表现就是方法重写。

##### 2.2.3 单分派与多分派

方法的接收者与方法的参数统称为方法的宗量。

单分派是根据一个宗量对目标方法进行选择。

多分派是根据多于一个宗量对目标方法进行选择。

```java
//多分派
Human a = new Man();
Human b = new Woman();
a.sayHi();
b.sayHello();
```

目前的 Java 语言是一门静态多分派、动态单分派的语言。

##### 2.2.4 动态分派实现

动态分派是执行非常频繁的动作，而且动态分派在方法版本选择过程中在方法元数据中搜索合适的目标方法，虚拟机实现不会频繁进行搜索。

优化手段：在类的方法区中建立一个虚方法表（Virtual Method Table），使用虚方法表索引来代替元数据查找以提高性能。

虚方法表中存放的是各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。

如果子类中重写了这个方法，子类虚方法表中的地址也会替换为指向子类实现版本的入口地址。

### 3. 基于栈的字节码解释执行引擎

#### 3.1 解释执行

Java语言经常被人们定位位“解释执行”的语言，但后来技术发展，只有确定了谈论对象是某种具体的 java 实现版本和执行引擎运行模式时，谈解释执行还是编译执行才会比较合理。

Java语言中，javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现。

#### 3.2 基于栈的指令集与基于寄存器的指令集

Java编译器输出的字节码指令流，基本上是一种基于栈的指令集架构（Instruction Set Architecture，ISA），字节码指令流里面的指令大部分都是零地址指令，依赖操作数栈进行工作。与之相对应的另一套常用的指令集架构是基于寄存器的指令集， 依赖寄存器进行工作。

两种指令集区计算 “1+1” 的结果，

- 基于栈的指令集：iconst_1	iconst_1	iadd	istore_0

  两条 iconst_1 指令连续把两个常量1压入栈后，iadd 指令把栈顶的两个值出栈、相加，然后把结果放回栈顶，最后 istore_0 把栈顶的值放到局部变量表的第0个变量槽中。

- 基于寄存器的指令集：mov  eax,1	add  eax,1

  mov指令把EAX寄存器的值设为1，然后add指令再把这个值加1，结果就保存在EAX寄存器里面。

基于栈的指令集主要优点是可移植，因为寄存器由硬件直接提高，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。还有代码相对更加紧凑，编译器实现更加简单。

栈架构指令集的主要缺点是理论上执行速度相对要慢一些。