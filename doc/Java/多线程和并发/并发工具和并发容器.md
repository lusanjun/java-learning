## 并发工具和并发容器

### 1.并发工具

#### 1.1 CountDownLatch计数门闩

倒数结束之前，一直处于等待状态，直到0，等待线程才继续工作。

场景：购物拼团，大巴车满人发车，分布式锁

主要方法：

- 构造函数：CountDownLatch(int count)：只有一个构造函数，参数count为需要倒数的数值。
- await()：当一个或多个线程调用await()时，这些线程会阻塞。
- countDown()：其他线程调用countDown()会将计数器减1，调用countDown方法的线程不会阻塞。当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行  

#### 1.2 Semaphore信号量

限制和管理数量有限的资源的使用

场景：Hystrix、Sentinel限流

信号量的作用就是维护一个“许可证”的计数，线程可以“获取”许可证，信号量剩余的许可证就减少一个。线程也可以“释放”一个许可证，信号量剩余的许可证就可以加一个。当信号量拥有的许可证为0时，下一个还要获取许可证的线程就需要等待，直到有另外的线程释放了许可证。

主要方法：

- 构造函数：Semaphore(int permits, Boolean fair)，可以设置公平策略。
- acquire()：获取许可证，要么获取成功，信号量减一，要么阻塞等待唤醒。
- release()：释放许可证，信号量加一，然后唤醒等待的线程

#### 1.3 CyclicBarrier循环栅栏

线程会等待，直到线程到了事先规定的数目，然后触发执行条件进行下一步动作。

当有大量线程互相配合，分别计算不同任务，并且需要最后统一汇总时，就可以用循环栅栏，它可以构造一个集结点，当某一个线程执行完，就会到集结点等待，直到所有线程都到集结点，则栅栏撤销，所有线程统一出发，继续执行剩下的任务。

主要方法：

- 构造函数：CyclicBarrier(int parties, Runnable barrierAction)，设置聚集的线程数量和集齐线程数的结果之后要执行的动作
- await()：阻塞当前线程，待凑齐线程数量之后继续执行

#### 1.4 Condition条件对象

当线程1需要等待某个条件时就去执行`condition.await()`方法，一旦执行await方法，线程就会进入阻塞状态。通常会有另一个线程2去执行对应条件，直到这个条件达成时，线程2就会执行`condition.sigal()`方法，此时JVM就会从被阻塞的线程理找到那些等待该condition的线程，当线程1收到可执行信号时，它的线程状态就会变成Runnable可执行状态。

signalAll()会唤起所有正在等待的线程。

signal()是公平的，只会唤起那个等待时间最长的线程

### 2. 并发容器

#### 2.1 并发容器

针对多线程并发访问来进行设计的集合，就是并发容器。每次只有一个线程可以访问的集合，称为线程安全的集合，也叫同步容器。

Java中的集合主要分为四大类：List、Map、Set和Queue。其中，ArrayList，HashMap，HashSet就不是线程安全的。

JDK早期线程安全的有：Vector、Stack、HashTable。JDK1.2中，还为Collections增加内部Synchronized类创建线程安全的集合，但性能差。

场景的并发容器：

- List：
  - Vector：synchronized实现的同步容器，性能差，适合对数据有强一致性要求的场景
  - CopyOnWriteArrayList：底层数组实现，使用复制副本进行有锁写操作，适合读多写少，允许短暂的数据不一致场景
- Map：
  - HashTable：synchronized实现的同步容器，性能差，适合对数据有强一致性要求的场景
  - ConcurrentHashMap：底层数组+链表+红黑树，对table数组entry用synchronized加锁。适合存储数据量小，读多写少，允许短暂的数据不一致场景
  - ConcurrentSkipListMap：底层跳表实现，使用CAS实现无锁读写操作。适合存储数据量的，读写频繁，允许短暂的数据不一致场景
- Set：
  - CopyOnWriteArraySet：底层数组实现的无序Set，使用复制副本实现有锁写操作，不能保证强一致性。适合于读多写少，允许读写数据短暂不一致的场景
  - ConcurrentSkipListSet：底层跳表实现的有序Set，使用CAS实现无锁化读写，具有弱一致性。适合于存储数据量大，读写都比较频繁，对数据不要求强一致性的高并发场景  

#### 2.2 ConcurrentHashMap

JDK7 中使用的是分段锁，每一个 Segment 上同时只有一个线程可以操作。冲突多了，会转化为链表。

JDK8 中同 HashMap ，转变为 Node 数组 + 链表/红黑树。

内部是 volatile 修饰的节点数组，保证可见性，禁止指令重排。

#### 2.3 CopyOnWriteArrayList

CopyOnWrite思想：查询不加锁，在更新时，会从原来的数据复制一个副本，然后修改这个副本，最后把原数据替换成当前的副本。修改操作的同时，读操作不会阻塞，而是继续读取旧数据。

优点：

- 对于读多写少的数据，写入时复制，是一种无锁的实现，可以实现更高的并发。
- CopyOnWriteArrayList 只在写操作加锁，并发安全且性能比Vector好，Vector是通过synchronized来保证同步，性能差。

缺点：

- 数据一致性问题：在添加到副本数据而没进行替换时，读到的仍是旧数据。
- 内存占用问题：如果对象比较大，频繁进行复制替换会消耗内存，会引发GC问题。