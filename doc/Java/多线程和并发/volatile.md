## volatile

### 1.多线程并发的三个特性

#### 1.1原子性

一个操作或多个操作，要么全部执行，要么都不执行，执行过程不能被打断

#### 1.2 有序性

程序代码按照先后顺序执行。为什么会出现无序问题，因为指令重排。

#### 1.3 可见性

当多个线程访问同一个变量，一个线程修改了变量的值，其他线程能够立即看到修改的新值。

为什么出现不可见性问题，因为Java内存模型（JMM）。

### 2.  volatile作用

Java允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。

volatile可以保证多线程场景下变量的可见性和有序性。  

- 可见性：保证此变量的修改对所有线程的可见性。
- 有序性：禁止指令重排序优化，编译器和处理器在进行指令优化时，不能把在volatile变量操作(读/写)后面的语句放到其前面执行，也不能将volatile变量操作前面的语句放在其后执行。  

### 3. 原理

#### 3.1 内存屏障

内存屏障（Memory Barrier）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序

- 写操作时，通过在写操作指令后加入一条store屏障指令，让本地内存中变量的值能够刷新到主内存中
- 读操作时，通过在读操作前加入一条load屏障指令，及时读取到变量在主内存的值

volatile修饰的变量，通过javap可以看到volatile字节码有个关键字`ACC_VOLATILE`，通过这个关键字可以定位到虚拟机源码上，

`lock; addl $0,0(%%)`作为cpu的一条内存屏障指令。

#### 3.2 JMM内存屏障插入策略

在每个volatile写前，插入StoreStore屏障

在每个volatile写后，插入StoreLoad屏障

在每个volatile读前，插入LoadLoad屏障

在每个volatile读后，插入LoadStore屏障

| 屏障类型   | 示例                     | 说明                                                         |
| ---------- | ------------------------ | ------------------------------------------------------------ |
| LoadLoad   | Load1;LoadLoad;Load2     | 确保装载动作Load1，先于 Load2及其后所有Load 操作。 对于屏障前后的Store操作并无影响。 |
| StoreStore | Store1;StoreStore;Store2 | 确保Store1刷新数据到内存(使数据对其他处理器可 见)的操作，先于Store2及其后所有Store指令的执 行。 对于屏障前后的Load操作并无影响。 |
| LoadStore  | Load1;LoadStore;Store2   | 确保屏障指令之前的所有Load操作，先于屏障之后 所有Store操作(刷新数据到主存)。 |
| StoreLoad  | Store1;StoreLoad;Load2   | 确保屏障之前的所有内存访问操作(包括Store和 Load)完成之后，才执行屏障之后的内存访问操作。 全能型屏障，会屏蔽屏障前后所有指令的重排。 |

#### 3.3 重排序规则表

| 第一个操作 | 普通读/写 | volatile读 | volatile写 |
| ---------- | --------- | ---------- | ---------- |
| 普通读     |           |            |            |
| 普通写     |           |            | N          |
| volatile读 | N         | N          | N          |
| volatile写 |           | N          | N          |

1. 当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序

   确保 volatile 读到的是最新值：volatile 读之后的操作不会被编译器重排序到 volatile 读之前

2. 当第一个操作是volatile写时，不管第二个操作是什么，都不能重排

   确保 volatile 写操作对之后的操作可见

3.  当第二个操作是volatile写时，第一个操作是普通写时，不能重排序  

### 4. 适合使用场景

- 对共享变量的写入操作不依赖其当前值，例如 ++ 和 -- 就不行
- 共享变量没有包含在有其他变量的不等式中

### 5.  缺陷

volatile不能在多线程下，不能确保原子性。

解决方案：

1. 使用 synchronized
2. 使用可重入锁 ReentrantLock
3. 使用原子类操作

### 6. 和 Synchronized 比较

- volatile不需要加锁，比synchronized更轻便，不会阻塞线程
- synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性
- 与synchronized相比volatile是一种非常简单的同步机制  